
/*:
# 外观 Facade -- 对象结构型模式

## 意图
为子系统中的一组接口提供一个简单的接口。Facade模式定义一个高层接口，这一接口使得这些子系统更容易使用。

## 动机
将一个系统分为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和耦合达到最小【子系统和Client之间的耦合关系达到最小】。达到该目标的途径之一就是引入一个外观（Facade）对象，它为子系统中比较一般的设施提供一个单一而简单的接口
![](1.png)

例如编译器就是一个集成了Parser、Scanner、ByteCodeStream等子系统的外观
![](2.png)

## 适用性
* 当你要为一个复杂系统提供一个简单接口时。子系统往往因为不断演化而变得复杂。大多数模式使用都会产生很多很小的类。这使得子系统更具复用性和扩展性，但是也给不需要扩展子系统的用户带来了使用上的困难。Facade可以提供一个简单的缺省接口，这一接口提供的功能对于大多数用户都是满足需要的，那些需要定制的用户可以越过Facade层。

* 客户程序与抽象类的实现部分之间有很大的依赖性。引用Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。

* 当你需要构建一个层次机构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让他恩仅通过Facade层进行通讯，从而简化了他们之间的依赖关系。

## 结构
![](3.png)

## 参与者
* Facade
-- 知道哪些子系统类负责处理相关请求
-- 将客户请求转发给相关的子系统

* Subsystem
-- 实现子系统的功能。
-- 处理由Facade派发的任务
-- 没有Facade任何相关信息，即没有指向Facade的指针

## 协作
* 客户程序通过发送请求给Facade的方式同子系统通讯，Facade将请求转发给对应的子系统对象。
* 使用Facade的客户端程序不需要直接访问子系统对象

## 效果
### 优点：
1. 它对客户屏蔽子系统组件。减小了客户需要了解的子系统对象，使子系统的使用更加方便
2. 实现了子系统和客户程序之间的松耦合关系，而子系统的内部功能组件往往是紧耦合的。Facade模式可以消除循环依赖。另外子系统之间也可以使用Facade模式，降低子系统之间的耦合性，同时在部分作出修改时，减小编译时间。
3. 如果应用需要，它并不会限制他们使用子系统类。

## 实现
使用Facade模式应该注意一下几点：
1. 降低客户--子系统之间的耦合度。用抽象类实现Facade模式，它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统之间的耦合。另一种方法是用不同的子系统对象配置Facade对象，为定义Facade，仅需要替换子系统对象。
2. 公共子系统和私有子系统类。子系统的公共接口包含所以客户程序可以访问的类，私有接口仅对子系统进行扩展。

## 相关模式
1. Abstract Factory模式可以和Facade模式一起使用以提供一个接口，这一接口可以用于以子系统独立的方式，创建子系统对象。Abstract Factory模式也可以替代Facade模式隐藏于平台有关的类。

2. Mediator模式与Facade模式有许多相似之处，它抽象了一些已有的类功能。但是Mediator模式的目的是对同事之间的任意通讯进行抽象，通常集中不属于任何单个对象的功能，Mediator中的同事知道Mediator的存在，并与之通讯，而不是直接与其他同事通讯。而Facade模式仅对子系统的接口进行抽象，从而使它们更容易使用，它不定义新功能，子系统也不是的Facade的存在。

3. 通常来讲，只需要一个Facade对象，通常和单例结合使用。


## 其他知识点

*/


import Cocoa

class Scanner {
	func scan() {}
}

class Parser {
	func parser() {}
}

class Compiler {
	private var scanner = Scanner()
	private var parser = Parser()
	
	func compileCode() {
		scanner.scan()
		parser.parser()
	}
}

class Client {
	func compileCode() {
		Compiler().compileCode()
	}
}

let client = Client()
client.compileCode()
