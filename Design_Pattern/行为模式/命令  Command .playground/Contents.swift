/*:
 # 命令模式 - Command  -- 对象行为模式
 
 ## 意图
 将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可撤消的操作。
 
 ## 别名
 动作(Action),事务(Transaction)
 
 ## 动机
 有时必须向某对象提交请求,但并不知道关于被请求的操作或请求的接受者的任何信息。
 例如,用户界面工具箱包括按钮和菜单这样的对象,它们执行请求响应用户输入。但工具箱不能显式的在按钮或菜单中实现该请求,因为只有使用工具箱的应用知道该由哪个对象做哪个操作。而工具箱的设计者无法知道请求的接受者或执行的操作。
 
 命令模式通过将请求本身变成一个对象来使工具箱对象可向未指定的应用对象提出请求。
 这个对象可被存储并像其他的对象一样被传递。这一模式的关键是一个抽象的 Command2类, 它定义了一个执行操作的接口。其最简单的形式是一个抽象的 Execute操作。具体的 Command 子类将接收者作为其一个实例变量,并实现 Execute操作,指定接收者采取的动作。而接收者有执行该请求所需的具体信息。

 > 个人领悟：这里的框架代表一个界面套件，里面的逻辑可以自定义实现。
 

 ## 适用性
 当你有如下需求时,可使用 Command模式:
 * 像上面讨论的 Menuitem对象那样,抽象出待执行的动作以参数化某对象。你可用过程语言中的回调( callback)函数表达这种参数化机制。所谓回调函数是指函数先在某处注册,而它将在稍后某个需要的时候被调用。 Command模式是回调机制的一个面向对象的替代品。
 * 在不同的时刻指定、排列和执行请求。一个 Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达,那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。
 * 支持取消操作。 Command的 Excute操作可在实施操作前将状态存储起来,在取消操作时这个状态用来消除该操作的影响。 Command接口必须添加一个 Unexecuted操作,该操作取消上一次 Executel调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用 Execute和 Execute来实现重数不限的“取消”和“重做
 * 支持修改日志,这样当系统崩溃时,这些修改可以被重做一遍。在 Command:接口中添加装载操作和存储操作,可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用 Execute操作重新执行它们。
 * 用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( transaction 的信息系统中很常见。一个事务封装了对数据的一组变动。 Command模式提供了对事务进行建模的方法。 Command有一个公共的接口,使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。

 
 ## 结构
 ![](1.png)
 

 ## 参与者
 
 -- Command
 * 声明执行操作的接口。
 
 -- Concrete(PastCommand, OpenCommand)
 * 将一个接收者对象绑定于一个动作。
 * 调用接收者相应的操作,以实现 Execute。
 
 -- Client(Appliction)
 * 创建一个具体命令对象并设定它的接收者。
 
 -- invoker(Menultem)
 * 要求该命令执行这个请求。
 
 -- Receiver(Document, Application)
 * 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。
 
 ## 协作
 * Client创建一个ConcreteCommand对象并指定它的Receiver对象。
 * 某 Invoker对象存储该ConcreteCommand对象。
 * 该加Invoker通过调用Command对象的 Execute操作来提交一个请求。若该命令是可撤消的, ConcreteCommand就在执行Excute操作之前存储当前状态以用于取消该命令。
 * ConcreteCommand对象对调用它的Receiver的一些操作以执行该请求。
 
 下图展示了这些对象之间的交互。它说明了 Command是如何将调用者和接收者(以及它执行的请求)解耦的。
 
 ![](2.png)
 
 ## 效果
 Command模式有以下效果
 1) Command模式将调用操作的对象与知道如何实现该操作的对象解耦。
 2) Command是头等的对象。它们可像其他的对象一样被操纵和扩展。
 3) 你可将多个命令装配成一个复合命令。例如是前面描述的MacroCommand类。一般说来,复合命令是Composites模式的一个实例。
 4) 增加新的Command很容易,因为这无結改变已有的类。
 
 ## 实现
 实现Command模式时须考虑以下问题:
 1) 一个命令对象应达到何种智能程度命令对象的能力可大可小。一个极端是它仅确定一个接收者和执行该请求的动作。另一极端是它自己实现所有功能,根本不需要额外的接收者对象。当需要定义与已有的类无关的命令,当没有合适的接收者,或当一个命令隐式地知道它的接收者时,可以使用后一极端方式。例如,创建另一个应用窗口的命令对象本身可能和任何其他的对象一样有能力创建该窗口。在这两个极端间的情况是命令对象有足够的信息可以动态的找到它们的接收者。
 
 2)支持取消(Undo)和重做(Redo)如果Command:提供方法逆转(Reverse)它们操作的执行(例如 Execute或Undo操作),就可支持取消和重做功能。为达到这个目的, Concrete Commande类可能需要存储额外的状态信息。这个状态包括:
 * 接收者对象,它真正执行处理该请求的各操作。
 * 接收者上执行操作的参数。
 * 如果处理请求的操作会改变接收者对象中的某些值,那么这些值也必须先存储起来。接收者还必须提供一些操作,以使该命令可将接收者恢复到它先前的状态。
 
 3) 避免取消操作过程中的错误积累在实现一个可靠的、能保持原先语义的取消/重做机制时,可能会遇到滞后影响问题。由于命令重复的执行、取消执行,和重执行的过程可能会积累错误,以至一个应用的状态最终偏离初始值。这就有必要在 Command中存入更多的信息以保证这些对象可被精确地复原成它们的初始状态。这里可使用Memento模式(5.6)来让该Command访问这些信息而不暴露其他对象的内部信息。
 
 4) 使用C+模板对(1)不能被取消(2)不需要参数的命令,我们可使用C++模板来实现, 这样可以避免为每一种动作和接收者都创建一个Command子类。我们将在代码示例一节说明这种做法。
 
 ## 相关模式
 * Composite模式(4.3)可被用来实现宏命令。
 * Memento模式(5.6)可用来保持某个状态,命令用这一状态来取消它的效果。
 * 在被放人历史表列前必须被拷贝的命令起到一种原型Prototype(3.4)的作用
 
 
 ## 其他知识点
 
 */


import Cocoa

protocol Receiver {
    func make()
}

protocol Command {
    var receiver: Receiver { get set}
    
    func execute()
}

struct PrintReceiver: Receiver {
    func make() {
        print("")
    }
}

struct PrintCommand: Command {
    init(receiver: PrintReceiver) {
        self.receiver = receiver
    }
    
    var receiver: Receiver
    
    func execute() {
        receiver.make()
    }
}

struct Invoker {
    func deal(command: Command) {
        command.execute()
    }
}

let invoke = Invoker()
let reciver = PrintReceiver()
let command = PrintCommand(receiver: reciver)

invoke.deal(command: command)
