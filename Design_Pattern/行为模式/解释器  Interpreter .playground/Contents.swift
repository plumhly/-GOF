/*:
 # 解释器 Interpreter -- 类行为模式
 
 ## 意图
 给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子。
 
 ## 动机
 解释器模式描述了如何为简单的语言定义一个文法,如何在该语言中表示一个句子,以及如何解释这些句子。在上面的例子中,本设计模式描述了如何为正则表达式定义一个文法,如何表示一个特定的正则表达式,以及如何解释这个正则表达式。

 ## 适用性
 当有一个语言需要解释执行,并且你可将该语言中的句子表示为一个抽象语法树时,可使用解释器模式。而当存在以下情况时该模式效果最好:
 * 该文法简单对于复杂的文法,文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式,这样可以节省空间而且还可能节省时间。
 * 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的,而是首先将它们转换成另一种形式。例如,正则表达式通常被转换成状态机。但即使在这种情况下,转换器仍可用解释器模式实现,该模式仍是有用的。

 ## 结构
 ![](1.png)
 
 
 ## 参与者
 -- Abstractexpression(抽象表达式,如Regularexpression
 * 声明一个抽象的解释操作,这个接口为抽象语法树中所有的节点所共享
 
 -- Terminalexpression(终结符表达式,如 Literalexpression)
 * 实现与文法中的终结符相关联的解释操作。
 * 一个句子中的每个终结符需要该类的一个实例
 
 -- Nonterminalexpression(非终结符表达式,如 Alternationexpression, RepetitionExpression, Sequenceexpressions)
 * 对文法中的每一条规则R:=R1R2…Rn都需要一个 NonterminalExpression类。
 * 为从Ra到Rn的每个符号都维护一个Abstractexpression类型的实例变量。
 * 为文法中的非终结符实现解释(Interpre)操作。解释(Interpret)一般要递归地调用表示R1到Rn的那些对象的解释操作。
 
 ## 协作
 * Client/构建(或被给定)一个句子,它是Nonterminalexpression和Terminalexpression的实例的一个抽象语法树.然后初始化上下文并调用解释操作。
 * 每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。
 * 每一节点的解释操作用上下文来存储和访问解释器的状态。
 
 
 ## 相关模式
 * Composite模式(4.3):抽象语法树是一个复合模式的实例。
 * Flyweigh模式(4.6)说明了如何在抽象语法树中共享终结符。
 * literator(5.4):解释器可用一个迭代器遍历该结构。
 * Visitor(5.11):可用来在一个类中维护抽象语法树中的各节点的行为。

 
 ## 其他知识点
 
 */


import Cocoa
