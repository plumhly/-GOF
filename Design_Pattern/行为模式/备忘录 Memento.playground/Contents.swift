/*:
 # 备忘录 - Memento  -- 对象行为型模式
 
 ## 意图
 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。
 样以后就可将该对象恢复到原先保存的状态
 
 ## 别名
 Token
 
 ## 动机
 有时有必要记录一个对象的内部状态。为了允许用户取消不确定的操作或从错误中恢复过来,需要实现检査点和取消机制,而要实现这些机制,你必须事先将状态信息保存在某处, 这样才能将对象恢复到它们先前的状态。但是对象通常封装了其部分或所有的状态信息,使得其状态不能被其他对象访问,也就不可能在该对象之外保存其状态。而暴露其内部状态又将违反封装的原则,可能有损应用的可靠性和可扩展性。
 
 我们可用备忘录( Memento)模式解决这一向题。一个备忘录(Memento)是一个对象,它存储另一个对象在某个瞬间的内部状态,而后者称为备忘录的原发器(Originator)。
 当需要设置原发器的检查点时,取消操作机制会向原发器请求一个备忘录。原发器用描述当前状态的信息初始化该备忘录。只有原发器可以向备忘录中存取信息,备忘录对其他的对象“不可见”。
 
 ## 适用性
 在以下情况下使用备忘录模式:
 * 必须保存一个对象在某一个时刻的(部分)状态,这样以后需要时它才能恢复到先前的状态。
 * 如果一个用接口来让其它对象直接得到这些状态,将会暴露对象的实现细节并破坏对象的封装性。
 
 ## 结构
 ![](1.png)
 
 ## 参与者
 -- Memento(备忘录,如Solverstate)
 * 备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。
 * 防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口,管理者(Caretaker)只能看到备忘录的窄接口一它只能将备忘录传递给其他对象。相反,原发器能够看到一个宽接口,允许它访问返回到先前状态所需的所有数据。
 理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。
 
 -- Originator(原发器,如Constraintsolver)
 * 原发器创建一个备忘录,用以记录当前时刻它的内部状态。
 * 使用备忘录恢复内部状态.。
 
 -- Caretaker(负责人,如 undo mechanism)
 * 负责保存好备忘录。
 * 不能对备忘录的内容进行操作或检査。
 
 ## 协作
 管理器向原发器请求一个备忘录,保留一段时间后,将其送回给原发器,如下面的交互图所示
 
 ![](2.png)
 
 ## 效果
 备忘录模式有以下一些效果:
 1) 保持封装边界。使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发器之外的信息。该模式把可能很复杂的Originator内部信息对其他对象屏蔽起来,从而保持了封装边界。
 
 2) 它简化了原发器。在其他的保持封装性的设计中, Originator负责保持客户请求过的内部状态版本。这就把所有存储管理的重任交给了 Originator。让客户管理它们请求的状态将会简化 Originator,并且使得客户工作结東时无需通知原发器。
 
 3) 使用备忘录可能代价很高。如果原发器在生成备忘录时必须拷贝并存储大量的信息,或者客户非常频繁地创建备忘录和恢复原发器状态,可能会导致非常大的开销。除非封装和恢复 Originator,状态的开销不大,
 否则该模式可能并不合适。参见实现一节中关于增量式改变的讨论。
 
 4) 定义窄接口和宽接口。在一些语言中可能难以保证只有原发器可访问备忘录的状态
 
 5) 维护备忘录的潜在代价。管理器负责删除它所维护的备忘录。然而,管理器不知道备忘录中有多少个状态。因此当存储备忘录时,一个本来很小的管理器,可能会产生大量的存储开销。
 
 ## 实现
 下面是当实现备忘录模式时应考虑的两个问题：
 1) 语言支持备忘录有两个接口:
 一个为原发器所使用的宽接口,一个为其他对象所使用的窄接口。理想的实现语言应可支持两级的静态保护。在C++中,可将 Originator作为的一个友元,并使 Memento宽接口为私有的。只有窄接口应该被声明为公共的。
 
 2)存储增量式改变如果备忘录的创建及其返回(给它们的原发器)的顺序是可预测的, 备忘录可以仅存储原发器内部状态的增量改变。
 例如,一个包含可撤消的命令的历史列表可使用备忘录以保证当命令被取消时,它们可以被恢复到正确的状态(参见Command(5.2)。历史列表定义了一个特定的顺序,按照这个顺序命令可以被取消和重做。
 这意味着备忘录可以只存储一个命令所产生的增量改变而不是它所影响的每一个对象的完整状态。在前面动机一节给出的例子中,约束解释器可以仅存储那些变化了的内部结构,以保持直线与矩形相连,而不是存储这些对象的绝对位置。
 
 
 ## 相关模式
 * Command(5.2):命令可使用备忘录来为可撤消的操作维护状态。
 * Iterator(5.4):如前所述备忘录可用于迭代
 
 
 
 ## 其他知识点
 
 */

import Cocoa

/// 宽接口
public protocol MementoForPublic {
    func method1()
}

/// 窄接口
private protocol MementoForPrivate {
    func method2()
}

struct Memento: MementoForPublic {
    func method1() {
        
    }
    
    
}

extension Memento: MementoForPrivate {
    func method2() {
        
    }
}

struct Originator {
    func createMemento() -> Memento {
        return Memento()
    }
    
    func update(with memento: Memento) {
        
    }
}


struct CareTaker {
    func save(memento: Memento) {
        
    }
    
    func findLast() -> Memento {
        return Memento()
    }
}

let orignator = Originator()
let memento = orignator.createMemento()
let careTaker = CareTaker()

careTaker.save(memento: memento)

orignator.update(with: careTaker.findLast())


